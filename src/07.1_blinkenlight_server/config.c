/* config.c: Loading and processing of config file

 Copyright (c) 2012-2016, Joerg Hoppe
 j_hoppe@t-online.de, www.retrocmp.com

 Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation
 the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 JOERG HOPPE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 23-Feb-2016  JH	added logic for const input controls
 14-Feb-2012  JH    created
 */

#define CONFIG_C_

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#ifdef WIN32
#define strcasecmp _stricmp	// grmbl
#endif

#include "blinkenlight_panels.h"

///// config file grammar and parser //////
#include    <antlr3.h>

#include "blinkenlight_panel_configLexer.h"
#include "blinkenlight_panel_configParser.h"

#include "print.h"
#include "blinkenbus.h"
#include "config.h"
#include "bitcalc.h"
#include "namevaluelist.h"

#include "main.h" // global blinkenlight_panel_list
/**********************************************************************
 * globals for use by ANTLR parser
 */
blinkenlight_panel_t *parser_cur_panel; // current panel
blinkenlight_control_t *parser_cur_control; // current control ;
blinkenlight_control_blinkenbus_register_wiring_t *parser_cur_register_wiring; // current control ;

char *parser_strip_quotes(char *parsed_string) // make "\"xxx\"" -> "xxx"
{
	static char buffer[1024];
	// parsed_string enthÃ¤lt nicht die umgebenden "...". mach sie weg
	strcpy(buffer, &(parsed_string[1]));
	buffer[strlen(buffer) - 1] = '\0';
	return buffer;
}

/*
 * load panel definitions over config file.
 * Uses the parser generated with ANTLR.
 * While parsing, "actions" fill the panel-strucht with parsed data.
 * These action access the struct over PARSER_LAST_* Macros
 *
 * See
 * - grammar and actions in file "blinkenlight_panel_config.g"
 * - commented grammar test program in "grammartest.c"
 *
 * In case of parsing errors, the parser prints error location to stderr and exits.
 *
 * Parameters:
 * 		filename - path to config file.
 */
void blinkenlight_panels_config_load(char *filename)
{
	//pANTLR3_UINT8 fName;
	pANTLR3_INPUT_STREAM input;
	pblinkenlight_panel_configLexer lxr;
	pANTLR3_COMMON_TOKEN_STREAM tstream;
	pblinkenlight_panel_configParser psr;

	blinkenlight_panels_clear(blinkenlight_panel_list);
	namevaluelist_constructor();

	// open input file
	input = antlr3AsciiFileStreamNew(filename);
	if (input == NULL) {
		print(LOG_ERR, "Unable to open file %s!\n", (char *) filename);
		exit(ANTLR3_ERR_NOFILE);
	}
	// set parsing to case insensitive
	input->setUcaseLA(input, ANTLR3_TRUE);

	// create lexer
	lxr = blinkenlight_panel_configLexerNew(input); // LexerNew is generated by ANTLR
	if (lxr == NULL) {
		print(LOG_ERR, "Unable to create the lexer due to malloc() failure!\n");
		exit(ANTLR3_ERR_NOMEM);
	}
	// create token stream
	tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));

	if (tstream == NULL) {
		print(LOG_ERR, "Out of memory trying to allocate token stream\n");
		exit(ANTLR3_ERR_NOMEM);
	}
	// create parser
	psr = blinkenlight_panel_configParserNew(tstream); // CParserNew is generated by ANTLR3
	if (psr == NULL) {
		print(LOG_ERR, "Out of memory trying to allocate parser\n");
		exit(ANTLR3_ERR_NOMEM);
	}

	/////////////////////////////////////////////////////////////
	// parse the file, by calling main rule
	// work is done in C-"actions" embedded into the grammar
	// these actions use callbacks from this module
	psr->definition_list(psr);
	/////////////////////////////////////////////////////////////

	// still running? config file syntax was fine, cleanup
	psr->free(psr);
	psr = NULL;
	tstream->free(tstream);
	tstream = NULL;
	lxr->free(lxr);
	lxr = NULL;
	input->close(input);
	input = NULL;
}

/*
 * Check, whether the config has not semantic errors
 * - no BLINKENBUS bit used in multiple controls
 * - no undefined bits in control value
 * result:
 * 1 = OK, 0 = error
 * Error messages to stderr
 */

// linear list of all register wiring references
typedef struct
{
	blinkenlight_panel_t *panel;
	blinkenlight_control_t *control;
	blinkenlight_control_blinkenbus_register_wiring_t *register_wiring;
} blinkenbus_register_wiring_ref_t;

int blinkenlight_panels_config_check(void)
{
#define MAX_REGISTER_WIRING_REFS	\
		(MAX_BLINKENLIGHT_PANELS * MAX_BLINKENLIGHT_PANEL_CONTROLS * MAX_BLINKENLIGHT_REGISTERS_PER_CONTROL)

	int ok;
	unsigned register_wiring_count;
	blinkenbus_register_wiring_ref_t register_wiring_ref[MAX_REGISTER_WIRING_REFS];
	unsigned i_panel, j_panel, i_control, j_control, i_register_wiring;
	unsigned i, j;
	blinkenlight_panel_t *p, *p1;
	blinkenlight_control_t *c, *c1;

	ok = 1; // switches to 0 on error

	// check for duplicate panel names
	for (i_panel = 0; ok && i_panel < blinkenlight_panel_list->panels_count; i_panel++)
		for (j_panel = i_panel + 1; ok && j_panel < blinkenlight_panel_list->panels_count;
				j_panel++) {
			p = &(blinkenlight_panel_list->panels[i_panel]);
			p1 = &(blinkenlight_panel_list->panels[j_panel]);
			if (!strcasecmp(p->name, p1->name)) {
				print(LOG_ERR, "Error #1 in config file: \n");
				print(LOG_ERR, "Duplicate panel name: \"%s\"\n", p->name);
				ok = 0;
			}
		}
	// build linear list of all register wiring usages
	register_wiring_count = 0;
	for (i_panel = 0; ok && i_panel < blinkenlight_panel_list->panels_count; i_panel++) {
		p = &(blinkenlight_panel_list->panels[i_panel]);

		// check for duplicate control names
		for (i_control = 0; ok && i_control < p->controls_count; i_control++)
			for (j_control = i_control + 1; ok && j_control < p->controls_count; j_control++) {
				c = &(p->controls[i_control]);
				c1 = &(p->controls[j_control]);
				if (!strcasecmp(c->name, c1->name)) {
					print(LOG_ERR, "Error #2 in config file: \n");
					print(LOG_ERR, "Duplicate control name in panel \"%s\": \"%s\"\n", p->name,
							c->name);
					ok = 0;
				}
			}

		for (i_control = 0; ok && i_control < p->controls_count; i_control++) {
			c = &(p->controls[i_control]);
			if (c->radix != 10 && c->radix != 8 && c->radix != 16) {
				print(LOG_ERR, "Error #3 in config file: \n");
				print(LOG_ERR,
						" Radix for panel \"%s\", control \"%s\" is %d, must be 10 or 8 or 16!\n",
						p->name, c->name, c->radix);
				ok = 0;
			}

			for (i_register_wiring = 0; i_register_wiring < c->blinkenbus_register_wiring_count;
					i_register_wiring++) {
				register_wiring_ref[register_wiring_count].register_wiring =
						&(c->blinkenbus_register_wiring[i_register_wiring]);
				register_wiring_ref[register_wiring_count].panel = p;
				register_wiring_ref[register_wiring_count].control = c;
				register_wiring_count++;
				assert(register_wiring_count < MAX_REGISTER_WIRING_REFS);
			}
		}
	}
	/*
	 * 1) every bit of an BLINKENBUS register must not be used in multiple control values
	 */
	// compare every register wiring with every other.
	// quadratic runtime ... hope this is ok.
	for (i = 0; ok && i < register_wiring_count; i++) {
		for (j = i + 1; ok && j < register_wiring_count; j++) {
			blinkenlight_control_blinkenbus_register_wiring_t *bbrw1, *bbrw2;
			bbrw1 = register_wiring_ref[i].register_wiring;
			bbrw2 = register_wiring_ref[j].register_wiring;
			// have register wiring i and j some common bitmask bits?
			if (( // same board?
			bbrw1->blinkenbus_board_address == bbrw2->blinkenbus_board_address) && ( // and same register ?
					bbrw1->board_register_space == bbrw2->board_register_space) && ( // and input/output same?
					bbrw1->board_register_address == bbrw2->board_register_address) && ( // and same register ?
					bbrw1->blinkenbus_bitmask & bbrw2->blinkenbus_bitmask)) {
				// error
				print(LOG_ERR, "Error #4 in config file: \n");
				print(LOG_ERR, "BLINKENBUS register bit(s) assigned to multiple controls:\n");
				print(LOG_ERR, "  BLINKENBUS board=0x%x, register=%s 0x%x, duplicate bits=0x%x\n",
						bbrw1->blinkenbus_board_address,
						blinkenlight_register_space_t_text(bbrw1->board_register_space),
						bbrw1->board_register_address,
						bbrw1->blinkenbus_bitmask & bbrw2->blinkenbus_bitmask);
				print(LOG_ERR, "  Control 1: panel=\"%s\", control=\"%s\"\n",
						register_wiring_ref[i].panel->name, register_wiring_ref[i].control->name);
				print(LOG_ERR, "  Control 2: panel=\"%s\", control=\"%s\"\n",
						register_wiring_ref[j].panel->name, register_wiring_ref[j].control->name);
				ok = 0;
			}
		}
	}
	/*
	 * 2) for every control: calculate len of defined value bits,
	 *    and check for missing bits in value
	 */
	for (i_panel = 0; i_panel < blinkenlight_panel_list->panels_count; i_panel++) {
		p = &(blinkenlight_panel_list->panels[i_panel]);
		for (i_control = 0; i_control < p->controls_count; i_control++) {
			uint64_t all_value_bits = 0;
			uint64_t cur_value_bits;
			// Check, which bits of "value" are defined by which BLINKENBUS register bits
			// - every value bit from 0..len-1 must be defined by a register
			// - no value bit maybe defined by more than one register
			c = &(p->controls[i_control]);

			for (i_register_wiring = 0; i_register_wiring < c->blinkenbus_register_wiring_count;
					i_register_wiring++) {
				blinkenlight_control_blinkenbus_register_wiring_t *bbrw =
						&(c->blinkenbus_register_wiring[i_register_wiring]);
                                                /* Test: only 8 bit registers used? */
					if (bbrw->blinkenbus_lsb > 7) {
						print(LOG_ERR, "Error in panel %s, control %s, register %d: lsb > 7!\n",
								p->name, c->name, i_register_wiring);
						ok = 0;
					}
					if (bbrw->blinkenbus_msb > 7) {
						print(LOG_ERR, "Error in panel %s, control %s, register %d: msb > 7!\n",
								p->name, c->name, i_register_wiring);
						ok = 0;
					}

				// Test: board numbers only 0..29
				if (bbrw->blinkenbus_board_address > BLINKENBUS_MAX_BOARD_ADDR) {
					print(LOG_ERR, "Error #5 in config file: \n");
					print(LOG_ERR, "Board addresses must be 0..%d for board type 0\n",
					BLINKENBUS_MAX_BOARD_ADDR);
					print(LOG_ERR, "Panel=%s, control=%s\n", p->name, c->name);
					print(LOG_ERR, "  Register: board=0x%x, space=%s, addr=0x%x, lsb..msb=%d..%d\n",
							bbrw->blinkenbus_board_address,
							blinkenlight_register_space_t_text(bbrw->board_register_space),
							bbrw->board_register_address, bbrw->blinkenbus_lsb,
							bbrw->blinkenbus_msb);
					ok = 0;
				}

				// Test: input register only connect to input controls,
				// similar for outputs
				if ((c->is_input && bbrw->board_register_space == output_register)
						|| (!c->is_input && bbrw->board_register_space == input_register)) {
					print(LOG_ERR, "Error #6 in config file: \n");
					print(LOG_ERR,
							"Panel=\"%s\", control=\"%s\", type=%s: input/output direction mismatch\n",
							p->name, c->name, blinkenlight_control_type_t_text(c->type));
					print(LOG_ERR, "  Register: board=0x%x, space=%s, addr=0x%x, lsb..msb=%d..%d\n",
							bbrw->blinkenbus_board_address,
							blinkenlight_register_space_t_text(bbrw->board_register_space),
							bbrw->board_register_address, bbrw->blinkenbus_lsb,
							bbrw->blinkenbus_msb);
					ok = 0;
				}

				// Test: every bit in value may only be defined by ONE register
				cur_value_bits = mount_bits_to_mask64(0, bbrw->blinkenbus_bitmask,
						bbrw->blinkenbus_lsb, bbrw->control_value_bit_offset);
				if (cur_value_bits & all_value_bits) {
					print(LOG_ERR, "Error #7 in config file: \n");
					print(LOG_ERR,
							"Panel=\"%s\", control=\"%s\": value bits are defined by multiple registers\n",
							p->name, c->name);
					print(LOG_ERR, "  Overdefined bits = 0x%llx\n",
							cur_value_bits & all_value_bits);
					print(LOG_ERR, "  Register: board=0x%x, space=%s, addr=0x%x, lsb..msb=%d..%d\n",
							bbrw->blinkenbus_board_address,
							blinkenlight_register_space_t_text(bbrw->board_register_space),
							bbrw->board_register_address, bbrw->blinkenbus_lsb,
							bbrw->blinkenbus_msb);
					ok = 0;
				}
				all_value_bits |= cur_value_bits;
			}
			if (c->blinkenbus_register_wiring_count > 0) {
				// non-const control:
				// Test: count bits in all_value bits, and check for missing bits.
			c->value_bitlen = get_msb_index64(all_value_bits) + 1;

			// len= 17, BitMask from len= 0x1ffff, all_value_bits = 0x1efff
			//	=> errmask = 0x01000 => error
			// first "0" bit must be have index == len, else there's a 0-hole in all_value_bits
			// set bits
			{
				uint64_t bitmask = BitmaskFromLen64[c->value_bitlen];
				uint64_t errmask = all_value_bits ^ bitmask; // all undefined bits now as 1
				// continuous blocks of undefined LSB's are allowed!
				int errmask_msb_index = get_msb_index64(errmask); // biggest undefined bit
				uint64_t errmask_with_all_lsbs_set = BitmaskFromLen64[errmask_msb_index + 1];
				if (errmask
						&& (errmask_msb_index >= c->value_bitlen
								|| errmask != errmask_with_all_lsbs_set)) //
						{
					print(LOG_ERR, "Error #8 in config file: \n");
					print(LOG_ERR,
							"Panel=\"%s\", control=\"%s\": Bit gaps in definition for value bits\n",
							p->name, c->name);
					print(LOG_ERR, "  Value bit mask = 0x%llx, undefined bits = 0x%llx\n", bitmask,
							errmask);
					ok = 0;
				}
			}
			}
		}
	}
	return ok;
}

